# æ¨¡å—ç”Ÿå‘½å‘¨æœŸ

Entity Engine çš„æ¨¡å—ç”Ÿå‘½å‘¨æœŸç®¡ç†æä¾›äº†ä¸‰é˜¶æ®µçš„æ¨¡å—åˆå§‹åŒ–æµç¨‹ï¼šé…ç½®è®¾ç½®ã€ç»„ä»¶æ³¨å†Œå’Œæ•°æ®åˆå§‹åŒ–ã€‚è¿™ç§åˆ†é˜¶æ®µè®¾è®¡ç¡®ä¿äº†ä¾èµ–å…³ç³»çš„æ­£ç¡®å¤„ç†å’Œç³»ç»Ÿçš„ç¨³å®šå¯åŠ¨ã€‚æ¯ä¸ªé˜¶æ®µéƒ½æœ‰æ˜ç¡®çš„èŒè´£å’Œæ‰§è¡Œé¡ºåºï¼Œè®©æ‚¨èƒ½å¤Ÿå®‰å…¨ã€å¯é åœ°æ„å»ºå¤æ‚çš„æ¨¡å—åŒ–åº”ç”¨ã€‚

## ä¸‰é˜¶æ®µç”Ÿå‘½å‘¨æœŸæ¦‚è§ˆ

Entity Engine é‡‡ç”¨åˆ†é˜¶æ®µçš„æ¨¡å—åˆå§‹åŒ–ç­–ç•¥ï¼ŒæŒ‰ç…§ä»¥ä¸‹é¡ºåºæ‰§è¡Œï¼š

### 1. é…ç½®é˜¶æ®µ (setupConfig)
- **ç›®çš„**ï¼šè®¾ç½®æ¨¡å—é…ç½®ã€éªŒè¯é…ç½®å‚æ•°
- **æ‰§è¡Œæ—¶æœº**ï¼šæ‰€æœ‰æ¨¡å—é¦–å…ˆå®Œæˆé…ç½®é˜¶æ®µ
- **ä¸»è¦ä»»åŠ¡**ï¼šè®¾ç½®é»˜è®¤é…ç½®ã€éªŒè¯å¿…éœ€å‚æ•°ã€ç¯å¢ƒé€‚é…

### 2. ç»„ä»¶é˜¶æ®µ (setupComponents) 
- **ç›®çš„**ï¼šæ³¨å†ŒæœåŠ¡ã€ç»„ä»¶å’Œäº‹ä»¶å¤„ç†å™¨
- **æ‰§è¡Œæ—¶æœº**ï¼šæ‰€æœ‰æ¨¡å—é…ç½®å®Œæˆå
- **ä¸»è¦ä»»åŠ¡**ï¼šæœåŠ¡æ³¨å†Œã€ç»„ä»¶æ³¨å†Œã€ä¾èµ–æ³¨å…¥

### 3. æ•°æ®é˜¶æ®µ (setupData)
- **æ‰§è¡Œæ—¶æœº**ï¼šæ‰€æœ‰ç»„ä»¶æ³¨å†Œå®Œæˆå
- **ç›®çš„**ï¼šæ‰§è¡Œæ•°æ®è¿ç§»ã€åˆå§‹åŒ–é»˜è®¤æ•°æ®
- **ä¸»è¦ä»»åŠ¡**ï¼šæ•°æ®åº“è¿ç§»ã€åˆ›å»ºé»˜è®¤æ•°æ®ã€æ•°æ®éªŒè¯

## æ¨¡å—æ³¨å†Œä¸å¯åŠ¨æµç¨‹

### åŸºæœ¬å¯åŠ¨æµç¨‹

```typescript
import { engine } from '@scenemesh/entity-engine';
import { MyModule } from './my-module';

// 1. æ³¨å†Œæ¨¡å—
engine.moduleRegistry.register(new MyModule());

// 2. å¯åŠ¨ Entity Engineï¼ˆè‡ªåŠ¨æ‰§è¡Œä¸‰é˜¶æ®µåˆå§‹åŒ–ï¼‰
await engine.start();
```

### æ‰¹é‡æ³¨å†Œæ¨¡å—

```typescript
// æ³¨å†Œå¤šä¸ªæ¨¡å—
engine.moduleRegistry.registerAll([
  new DatabaseModule(),
  new AuthModule(),
  new UserModule(),
  new BlogModule()
]);

// å¯åŠ¨ç³»ç»Ÿ
await engine.start();
```

## setupConfig é˜¶æ®µè¯¦è§£

é…ç½®é˜¶æ®µæ˜¯æ¨¡å—åˆå§‹åŒ–çš„ç¬¬ä¸€æ­¥ï¼Œè´Ÿè´£è®¾ç½®å’ŒéªŒè¯æ¨¡å—é…ç½®ã€‚

### åŸºæœ¬é…ç½®è®¾ç½®

```typescript
async setupConfig({ configManager, logger }) {
  // è®¾ç½®é»˜è®¤é…ç½®
  configManager.setDefault(this.info.name, {
    database: {
      host: 'localhost',
      port: 5432,
      maxConnections: 10
    },
    cache: {
      enabled: true,
      ttl: 3600
    },
    logging: {
      level: 'info'
    }
  });

  logger.info(`${this.info.name} configuration initialized`);
}
```

### é…ç½®éªŒè¯

```typescript
async setupConfig({ configManager, logger }) {
  // è®¾ç½®é»˜è®¤é…ç½®
  configManager.setDefault(this.info.name, {
    apiUrl: 'https://api.example.com',
    apiKey: '',
    timeout: 5000
  });

  // è·å–é…ç½®è¿›è¡ŒéªŒè¯
  const config = configManager.get(this.info.name);

  // éªŒè¯å¿…éœ€é…ç½®
  if (!config.apiKey) {
    throw new Error('API key is required for external service integration');
  }

  // éªŒè¯é…ç½®èŒƒå›´
  if (config.timeout < 1000 || config.timeout > 30000) {
    logger.warn('Timeout out of recommended range, adjusting to default');
    configManager.set(`${this.info.name}.timeout`, 5000);
  }

  // éªŒè¯URLæ ¼å¼
  try {
    new URL(config.apiUrl);
  } catch (error) {
    throw new Error(`Invalid API URL: ${config.apiUrl}`);
  }

  logger.info('Configuration validated successfully');
}
```

### ç¯å¢ƒç‰¹å®šé…ç½®

```typescript
async setupConfig({ configManager, logger }) {
  // åŸºç¡€é…ç½®
  const baseConfig = {
    debug: false,
    logLevel: 'warn',
    cacheSize: 1000
  };

  // æ ¹æ®ç¯å¢ƒè°ƒæ•´é…ç½®
  if (process.env.NODE_ENV === 'development') {
    Object.assign(baseConfig, {
      debug: true,
      logLevel: 'debug',
      cacheSize: 100
    });
  } else if (process.env.NODE_ENV === 'test') {
    Object.assign(baseConfig, {
      logLevel: 'error',
      cacheSize: 50
    });
  }

  configManager.setDefault(this.info.name, baseConfig);

  // ä»ç¯å¢ƒå˜é‡è¦†ç›–é…ç½®
  const envOverrides = {};
  if (process.env.LOG_LEVEL) {
    envOverrides.logLevel = process.env.LOG_LEVEL;
  }
  if (process.env.CACHE_SIZE) {
    envOverrides.cacheSize = parseInt(process.env.CACHE_SIZE);
  }

  if (Object.keys(envOverrides).length > 0) {
    configManager.merge(this.info.name, envOverrides);
    logger.info('Applied environment configuration overrides');
  }
}
```

## setupComponents é˜¶æ®µè¯¦è§£

ç»„ä»¶é˜¶æ®µè´Ÿè´£æ³¨å†ŒæœåŠ¡ã€ç»„ä»¶å’Œå»ºç«‹ä¾èµ–å…³ç³»ã€‚

### æœåŠ¡æ³¨å†Œ

```typescript
async setupComponents({ serviceRegistry, componentRegistry, configManager, logger }) {
  const config = configManager.get(this.info.name);

  // æ³¨å†Œæ ¸å¿ƒæœåŠ¡
  serviceRegistry.register('DatabaseService', 
    new DatabaseService(config.database)
  );

  // æ³¨å†Œä¾èµ–å…¶ä»–æœåŠ¡çš„æœåŠ¡
  const dbService = serviceRegistry.get('DatabaseService');
  serviceRegistry.register('UserRepository', 
    new UserRepository(dbService)
  );

  // æ³¨å†Œç¼“å­˜æœåŠ¡ï¼ˆå¦‚æœå¯ç”¨ï¼‰
  if (config.cache.enabled) {
    serviceRegistry.register('CacheService', 
      new CacheService(config.cache)
    );
  }

  logger.info('Core services registered successfully');
}
```

### ç»„ä»¶æ³¨å†Œ

```typescript
async setupComponents({ serviceRegistry, componentRegistry, logger }) {
  // æ³¨å†Œè§†å›¾ç»„ä»¶
  componentRegistry.registerView(new UserListView());
  componentRegistry.registerView(new UserDetailView());
  componentRegistry.registerView(new UserFormView());

  // æ³¨å†Œæ•°æ®é€‚é…å™¨
  componentRegistry.registerAdapter(new UserDataAdapter());

  // æ³¨å†Œæ¸²æŸ“å™¨
  componentRegistry.registerRenderer({
    name: 'UserStatusRenderer',
    slotName: 'status',
    render: (data) => renderUserStatus(data)
  });

  logger.info('UI components registered successfully');
}
```

### ä¾èµ–æ³¨å…¥å’ŒæœåŠ¡è·å–

```typescript
async setupComponents({ serviceRegistry, configManager, logger }) {
  // è·å–ä¾èµ–çš„æœåŠ¡
  const dbService = serviceRegistry.get('DatabaseService');
  const eventService = serviceRegistry.get('EventService');
  
  if (!dbService) {
    throw new Error('DatabaseService is required but not available');
  }

  // æ³¨å†Œéœ€è¦ä¾èµ–çš„æœåŠ¡
  serviceRegistry.register('NotificationService', 
    new NotificationService(dbService, eventService)
  );

  // å¯é€‰ä¾èµ–å¤„ç†
  const cacheService = serviceRegistry.get('CacheService');
  if (cacheService) {
    logger.info('Cache service available, enabling caching');
    serviceRegistry.register('CachedUserService',
      new CachedUserService(dbService, cacheService)
    );
  } else {
    logger.warn('Cache service not available, using direct database access');
    serviceRegistry.register('CachedUserService', 
      new UserService(dbService)
    );
  }
}
```

### äº‹ä»¶å¤„ç†å™¨æ³¨å†Œ

```typescript
async setupComponents({ serviceRegistry, logger }) {
  // è·å–äº‹ä»¶æ³¨å†Œè¡¨
  const eventRegistry = serviceRegistry.get('EventRegistry');
  
  if (eventRegistry) {
    // æ³¨å†Œäº‹ä»¶å¤„ç†å™¨
    eventRegistry.on('user.created', async (userData) => {
      await this.handleUserCreated(userData);
    });

    eventRegistry.on('user.updated', async (userData) => {
      await this.handleUserUpdated(userData);
    });

    eventRegistry.on('user.deleted', async (userId) => {
      await this.handleUserDeleted(userId);
    });

    logger.info('Event handlers registered successfully');
  }
}

private async handleUserCreated(userData) {
  // ç”¨æˆ·åˆ›å»ºåçš„å¤„ç†é€»è¾‘
  const notificationService = serviceRegistry.get('NotificationService');
  await notificationService.sendWelcomeEmail(userData);
}
```

## setupData é˜¶æ®µè¯¦è§£

æ•°æ®é˜¶æ®µè´Ÿè´£æ‰§è¡Œæ•°æ®åº“è¿ç§»ã€åˆ›å»ºé»˜è®¤æ•°æ®å’Œæ•°æ®éªŒè¯ã€‚

### æ•°æ®è¡¨åˆ›å»º

```typescript
async setupData({ serviceRegistry, logger }) {
  const dbService = serviceRegistry.get('DatabaseService');

  try {
    // æ£€æŸ¥è¡¨æ˜¯å¦å­˜åœ¨
    const tablesExist = await dbService.checkTables(['users', 'user_profiles']);
    
    if (!tablesExist) {
      // åˆ›å»ºç”¨æˆ·è¡¨
      await dbService.createTable('users', {
        id: { type: 'string', primaryKey: true },
        username: { type: 'string', unique: true, maxLength: 50 },
        email: { type: 'string', unique: true, maxLength: 255 },
        passwordHash: { type: 'string', maxLength: 255 },
        status: { type: 'string', enum: ['active', 'inactive', 'suspended'], default: 'active' },
        createdAt: { type: 'datetime', default: 'now()' },
        updatedAt: { type: 'datetime', default: 'now()' }
      });

      // åˆ›å»ºç”¨æˆ·èµ„æ–™è¡¨
      await dbService.createTable('user_profiles', {
        id: { type: 'string', primaryKey: true },
        userId: { type: 'string', foreignKey: 'users.id' },
        firstName: { type: 'string', maxLength: 50 },
        lastName: { type: 'string', maxLength: 50 },
        avatar: { type: 'string', nullable: true },
        bio: { type: 'text', nullable: true },
        preferences: { type: 'json', nullable: true }
      });

      logger.info('Database tables created successfully');
    }

    // æ‰§è¡Œæ•°æ®è¿ç§»
    await this.runDataMigrations(dbService, logger);

  } catch (error) {
    logger.error('Data initialization failed:', error);
    throw error;
  }
}
```

### æ•°æ®è¿ç§»ç®¡ç†

```typescript
private async runDataMigrations(dbService, logger) {
  // æ£€æŸ¥è¿ç§»è¡¨æ˜¯å¦å­˜åœ¨
  await dbService.ensureTable('_migrations', {
    version: { type: 'string', primaryKey: true },
    appliedAt: { type: 'datetime', default: 'now()' }
  });

  // å®šä¹‰è¿ç§»è„šæœ¬
  const migrations = [
    {
      version: '1.0.1',
      description: 'Add user status column',
      script: async (db) => {
        await db.addColumn('users', 'status', {
          type: 'string',
          enum: ['active', 'inactive', 'suspended'],
          default: 'active'
        });
      }
    },
    {
      version: '1.1.0', 
      description: 'Create user preferences table',
      script: async (db) => {
        await db.createTable('user_preferences', {
          userId: { type: 'string', primaryKey: true, foreignKey: 'users.id' },
          theme: { type: 'string', default: 'light' },
          language: { type: 'string', default: 'en' },
          notifications: { type: 'json', default: '{}' }
        });
      }
    }
  ];

  // æ‰§è¡Œæœªåº”ç”¨çš„è¿ç§»
  for (const migration of migrations) {
    const applied = await dbService.findOne('_migrations', { version: migration.version });
    
    if (!applied) {
      logger.info(`Applying migration ${migration.version}: ${migration.description}`);
      
      try {
        await migration.script(dbService);
        await dbService.insert('_migrations', { version: migration.version });
        
        logger.info(`Migration ${migration.version} applied successfully`);
      } catch (error) {
        logger.error(`Migration ${migration.version} failed:`, error);
        throw error;
      }
    }
  }
}
```

### é»˜è®¤æ•°æ®åˆ›å»º

```typescript
async setupData({ serviceRegistry, configManager, logger }) {
  const dbService = serviceRegistry.get('DatabaseService');
  const config = configManager.get(this.info.name);

  // åˆ›å»ºé»˜è®¤ç®¡ç†å‘˜ç”¨æˆ·
  await this.createDefaultAdmin(dbService, config, logger);
  
  // åˆ›å»ºé»˜è®¤è§’è‰²
  await this.createDefaultRoles(dbService, logger);
  
  // åˆ›å»ºé»˜è®¤è®¾ç½®
  await this.createDefaultSettings(dbService, config, logger);
}

private async createDefaultAdmin(dbService, config, logger) {
  const adminExists = await dbService.findOne('users', { username: 'admin' });
  
  if (!adminExists) {
    const adminUser = {
      id: generateId(),
      username: 'admin',
      email: config.admin?.email || 'admin@example.com',
      passwordHash: await hashPassword(config.admin?.password || 'admin123'),
      status: 'active'
    };

    await dbService.insert('users', adminUser);
    
    // åˆ›å»ºç®¡ç†å‘˜èµ„æ–™
    await dbService.insert('user_profiles', {
      id: generateId(),
      userId: adminUser.id,
      firstName: 'System',
      lastName: 'Administrator',
      bio: 'Default system administrator'
    });

    logger.info('Default administrator created');
    logger.warn('Please change the default admin password immediately');
  }
}

private async createDefaultRoles(dbService, logger) {
  await dbService.ensureTable('roles', {
    id: { type: 'string', primaryKey: true },
    name: { type: 'string', unique: true },
    description: { type: 'string' },
    permissions: { type: 'json', default: '[]' }
  });

  const defaultRoles = [
    {
      name: 'admin',
      description: 'System Administrator',
      permissions: ['*']
    },
    {
      name: 'user',
      description: 'Regular User',
      permissions: ['read:profile', 'update:profile']
    },
    {
      name: 'guest',
      description: 'Guest User',
      permissions: ['read:public']
    }
  ];

  for (const role of defaultRoles) {
    const exists = await dbService.findOne('roles', { name: role.name });
    if (!exists) {
      await dbService.insert('roles', {
        id: generateId(),
        ...role
      });
    }
  }

  logger.info('Default roles created');
}
```

## ç”Ÿå‘½å‘¨æœŸæœ€ä½³å®è·µ

### 1. é…ç½®é˜¶æ®µæœ€ä½³å®è·µ

```typescript
async setupConfig({ configManager, logger }) {
  try {
    // 1. è®¾ç½®å®Œæ•´çš„é»˜è®¤é…ç½®
    const defaultConfig = {
      server: {
        port: 3000,
        host: '0.0.0.0',
        cors: {
          enabled: true,
          origins: ['http://localhost:3000']
        }
      },
      security: {
        jwtSecret: '',
        sessionTimeout: 3600000,
        passwordPolicy: {
          minLength: 8,
          requireUppercase: true,
          requireNumbers: true
        }
      }
    };

    configManager.setDefault(this.info.name, defaultConfig);

    // 2. éªŒè¯å¿…éœ€é…ç½®
    const config = configManager.get(this.info.name);
    this.validateRequiredConfig(config);

    // 3. åº”ç”¨ç¯å¢ƒç‰¹å®šè®¾ç½®
    this.applyEnvironmentConfig(configManager);

    // 4. è®°å½•é…ç½®çŠ¶æ€
    logger.info('Configuration setup completed', {
      port: config.server.port,
      corsEnabled: config.server.cors.enabled,
      environment: process.env.NODE_ENV || 'development'
    });

  } catch (error) {
    logger.error('Configuration setup failed:', error);
    throw error;
  }
}

private validateRequiredConfig(config) {
  const required = [
    'security.jwtSecret',
    'server.port'
  ];

  for (const path of required) {
    const value = this.getNestedValue(config, path);
    if (!value) {
      throw new Error(`Required configuration missing: ${path}`);
    }
  }
}
```

### 2. ç»„ä»¶é˜¶æ®µæœ€ä½³å®è·µ

```typescript
async setupComponents({ serviceRegistry, componentRegistry, configManager, logger }) {
  try {
    // 1. æŒ‰ä¾èµ–é¡ºåºæ³¨å†ŒæœåŠ¡
    await this.registerCoreServices(serviceRegistry, configManager);
    await this.registerBusinessServices(serviceRegistry);
    await this.registerUIComponents(componentRegistry);

    // 2. éªŒè¯å…³é”®ä¾èµ–
    this.validateCriticalDependencies(serviceRegistry);

    // 3. è®¾ç½®äº‹ä»¶å¤„ç†
    this.setupEventHandlers(serviceRegistry);

    logger.info('All components registered successfully');

  } catch (error) {
    logger.error('Component registration failed:', error);
    throw error;
  }
}

private async registerCoreServices(serviceRegistry, configManager) {
  const config = configManager.get(this.info.name);
  
  // æŒ‰ä¾èµ–é¡ºåºæ³¨å†Œ
  serviceRegistry.register('ConfigService', new ConfigService(config));
  serviceRegistry.register('DatabaseService', new DatabaseService(config.database));
  serviceRegistry.register('AuthService', new AuthService(config.security));
}

private validateCriticalDependencies(serviceRegistry) {
  const critical = ['DatabaseService', 'AuthService'];
  
  for (const serviceName of critical) {
    if (!serviceRegistry.has(serviceName)) {
      throw new Error(`Critical service not available: ${serviceName}`);
    }
  }
}
```

### 3. æ•°æ®é˜¶æ®µæœ€ä½³å®è·µ

```typescript
async setupData({ serviceRegistry, logger }) {
  const dbService = serviceRegistry.get('DatabaseService');
  
  try {
    // 1. æ•°æ®åº“è¿æ¥æµ‹è¯•
    await this.testDatabaseConnection(dbService);

    // 2. ç»“æ„è¿ç§»
    await this.runSchemaMigrations(dbService, logger);

    // 3. æ•°æ®è¿ç§»
    await this.runDataMigrations(dbService, logger);

    // 4. é»˜è®¤æ•°æ®åˆ›å»º
    await this.createDefaultData(dbService, logger);

    // 5. æ•°æ®å®Œæ•´æ€§æ£€æŸ¥
    await this.validateDataIntegrity(dbService, logger);

    logger.info('Data initialization completed successfully');

  } catch (error) {
    logger.error('Data initialization failed:', error);
    
    // æä¾›æ¢å¤å»ºè®®
    this.provideRecoveryGuidance(error, logger);
    throw error;
  }
}

private async testDatabaseConnection(dbService) {
  try {
    await dbService.query('SELECT 1');
  } catch (error) {
    throw new Error(`Database connection failed: ${error.message}`);
  }
}

private provideRecoveryGuidance(error, logger) {
  if (error.message.includes('connection')) {
    logger.error('Recovery: Check database connection settings and ensure database server is running');
  } else if (error.message.includes('permission')) {
    logger.error('Recovery: Check database user permissions');
  } else if (error.message.includes('migration')) {
    logger.error('Recovery: Check migration scripts and database schema');
  }
}
```

## é”™è¯¯å¤„ç†ä¸è°ƒè¯•

### ç”Ÿå‘½å‘¨æœŸé”™è¯¯å¤„ç†

```typescript
export class RobustModule implements IEntityModule {
  readonly info = { /* ... */ };

  async setupConfig({ configManager, logger }) {
    try {
      // é…ç½®è®¾ç½®é€»è¾‘
      await this.performConfigSetup(configManager);
    } catch (error) {
      logger.error('Configuration setup failed:', error);
      
      // æä¾›é»˜è®¤é…ç½®ä½œä¸ºå›é€€
      this.setupFallbackConfig(configManager, logger);
    }
  }

  async setupComponents({ serviceRegistry, logger }) {
    const registrationErrors = [];

    // å°è¯•æ³¨å†Œæ¯ä¸ªç»„ä»¶ï¼Œæ”¶é›†é”™è¯¯
    const components = this.getComponentRegistrations();
    
    for (const component of components) {
      try {
        await component.register(serviceRegistry);
        logger.debug(`Component registered: ${component.name}`);
      } catch (error) {
        registrationErrors.push({ component: component.name, error });
        logger.warn(`Component registration failed: ${component.name}`, error);
      }
    }

    // æ£€æŸ¥å…³é”®ç»„ä»¶æ˜¯å¦æˆåŠŸæ³¨å†Œ
    const criticalComponents = ['DatabaseService', 'AuthService'];
    const missingCritical = criticalComponents.filter(
      name => !serviceRegistry.has(name)
    );

    if (missingCritical.length > 0) {
      throw new Error(`Critical components missing: ${missingCritical.join(', ')}`);
    }

    if (registrationErrors.length > 0) {
      logger.warn(`${registrationErrors.length} non-critical components failed to register`);
    }
  }

  async setupData({ serviceRegistry, logger }) {
    const dbService = serviceRegistry.get('DatabaseService');
    
    // ä½¿ç”¨äº‹åŠ¡ç¡®ä¿æ•°æ®ä¸€è‡´æ€§
    await dbService.transaction(async (trx) => {
      try {
        await this.runMigrations(trx, logger);
        await this.createDefaultData(trx, logger);
        
        logger.info('Data setup completed successfully');
      } catch (error) {
        logger.error('Data setup failed, rolling back transaction:', error);
        throw error; // äº‹åŠ¡ä¼šè‡ªåŠ¨å›æ»š
      }
    });
  }
}
```

### æ¨¡å—å¯åŠ¨ç›‘æ§

```typescript
// ç›‘æ§æ¨¡å—å¯åŠ¨è¿‡ç¨‹
engine.on('module.config.start', ({ moduleName }) => {
  console.log(`âš™ï¸  Configuring ${moduleName}...`);
});

engine.on('module.config.complete', ({ moduleName, duration }) => {
  console.log(`âœ… ${moduleName} configured in ${duration}ms`);
});

engine.on('module.components.start', ({ moduleName }) => {
  console.log(`ğŸ”§ Registering ${moduleName} components...`);
});

engine.on('module.components.complete', ({ moduleName, servicesCount, duration }) => {
  console.log(`âœ… ${moduleName} registered ${servicesCount} services in ${duration}ms`);
});

engine.on('module.data.start', ({ moduleName }) => {
  console.log(`ğŸ“Š Initializing ${moduleName} data...`);
});

engine.on('module.data.complete', ({ moduleName, migrationsRun, duration }) => {
  console.log(`âœ… ${moduleName} data initialized (${migrationsRun} migrations) in ${duration}ms`);
});

engine.on('module.error', ({ moduleName, phase, error }) => {
  console.error(`âŒ ${moduleName} failed in ${phase}: ${error.message}`);
});
```

## ä¸‹ä¸€æ­¥

äº†è§£æ¨¡å—ç”Ÿå‘½å‘¨æœŸç®¡ç†åï¼Œç»§ç»­å­¦ä¹ ï¼š

- [ä¾èµ–æ³¨å…¥](./dependency-injection) - æ·±å…¥äº†è§£ä¾èµ–æ³¨å…¥æœºåˆ¶å’ŒæœåŠ¡è·å–
- [æœåŠ¡æ³¨å†Œ](./service-registration) - æŒæ¡æœåŠ¡æ³¨å†Œå’Œç®¡ç†çš„æœ€ä½³å®è·µ
- [é…ç½®ç®¡ç†](./configuration-management) - å­¦ä¹ æ¨¡å—é…ç½®ç³»ç»Ÿçš„é«˜çº§åŠŸèƒ½