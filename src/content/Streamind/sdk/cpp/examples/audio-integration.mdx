# éŸ³é¢‘é›†æˆç¤ºä¾‹

å®Œæ•´çš„ TTS éŸ³é¢‘å¤„ç†ç¤ºä¾‹ï¼Œå±•ç¤ºå¦‚ä½•æ¥æ”¶å¹³å°çš„ TTS éŸ³é¢‘æµå¹¶æ’­æ”¾ã€‚

## æ¦‚è¿°

æœ¬ç¤ºä¾‹å±•ç¤ºå®Œæ•´çš„ TTS éŸ³é¢‘æ’­æ”¾æµç¨‹ï¼š
1. æ¥æ”¶ `audio.opus_data_start` æŒ‡ä»¤ï¼ˆå¼€å¯æ’­æ”¾ï¼‰
2. é€šè¿‡ `SetAudioDataCallback` æ¥æ”¶ OPUS éŸ³é¢‘æµ
3. æ’­æ”¾å®Œæˆåä¸ŠæŠ¥ç»“æœ

## å®Œæ•´ä»£ç 

```cpp
#include <streamind.h>
#include <esp_log.h>
#include <esp_timer.h>
#include <cJSON.h>
#include <atomic>

static const char* TAG = "AudioTTSExample";

// å…¨å±€æ’­æ”¾æ§åˆ¶é—¨æ§ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰
static std::atomic<bool> playback_enabled_(false);

// éŸ³é¢‘è§£ç é˜Ÿåˆ—ï¼ˆå‡è®¾æœ‰ AudioService ç±»ï¼‰
extern bool PushToAudioDecodeQueue(const uint8_t* data, size_t size);

// ============================================
// ç¬¬ 1 æ­¥ï¼šæ³¨å†Œ audio.opus_data_start æŒ‡ä»¤
// ============================================

class AudioTTSIntegration {
public:
    static std::string GetModuleName() { return "audio"; }

    static void RegisterCapabilities(streamind::CapabilityRegistry& registry) {
        // æ³¨å†Œ TTS æ’­æ”¾å¼€å§‹æŒ‡ä»¤
        registry.RegisterAction("audio.opus_data_start", HandleOpusDataStart);
        ESP_LOGI(TAG, "AudioTTS registered: 1 action");
    }

private:
    static bool HandleOpusDataStart(const streamind::foundation::Directive& directive) {
        std::string send_id = directive.GetId();
        auto& sdk = streamind::SDK::GetInstance();

        // å®šä¹‰å¼‚æ­¥ä»»åŠ¡å‡½æ•°ï¼ˆæ£€æŸ¥çŠ¶æ€å¹¶å¯ç”¨æ’­æ”¾ï¼‰
        auto action_func = [send_id]() -> bool {
            // æ£€æŸ¥å½“å‰çŠ¶æ€ï¼ˆå®é™…é¡¹ç›®ä¸­ä» Application è·å–ï¼‰
            bool is_listening = false;

            if (is_listening) {
                ESP_LOGW(TAG, "Listening in progress, rejecting playback");
                return false;  // æ‹’ç»æ’­æ”¾
            } else {
                ESP_LOGI(TAG, "Playback enabled");
                playback_enabled_ = true;  // ğŸ”‘ å¯ç”¨æ’­æ”¾é—¨æ§
                return true;
            }
        };

        // å®šä¹‰å®Œæˆå›è°ƒï¼ˆä¸ŠæŠ¥æ‰§è¡Œç»“æœåˆ°å¹³å°ï¼‰
        auto completion_callback = [send_id](const std::string& task_id, bool success) {
            // åˆ›å»ºç»“æœ Signal
            cJSON* result_payload = cJSON_CreateObject();
            cJSON_AddStringToObject(result_payload, "directive", "audio.opus_data_start");
            cJSON_AddStringToObject(result_payload, "status", "success");
            cJSON_AddBoolToObject(result_payload, "playback_started", success);
            cJSON_AddNumberToObject(result_payload, "timestamp", esp_timer_get_time() / 1000);

            if (!send_id.empty()) {
                cJSON_AddStringToObject(result_payload, "_sendId_", send_id.c_str());
            }

            if (!success) {
                cJSON_AddStringToObject(result_payload, "reason", "listening_in_progress");
            }

            // ğŸ”‘ ä¸ŠæŠ¥ç»“æœåˆ°å¹³å°
            streamind::foundation::Signal signal("sys.directive.result");
            signal.GetPayload()->FromJson(result_payload);

            auto& sdk = streamind::SDK::GetInstance();
            sdk.SendSignal(signal);

            cJSON_Delete(result_payload);
            ESP_LOGI(TAG, "Result reported: playback_started=%s", success ? "true" : "false");
        };

        // ä½¿ç”¨ ExecuteHardwareTask å¼‚æ­¥æ‰§è¡Œ
        std::string task_id = sdk.ExecuteHardwareTask(
            "audio.opus_data_start",
            "audio",
            action_func,
            completion_callback,
            send_id
        );

        return !task_id.empty();
    }
};

// ============================================
// ç¬¬ 2 æ­¥ï¼šè®¾ç½®éŸ³é¢‘æ•°æ®å›è°ƒï¼ˆæ¥æ”¶ TTS æµï¼‰
// ============================================

void SetupAudioDataCallback(streamind::SDK& sdk) {
    sdk.SetAudioDataCallback([](const uint8_t* data, size_t size, const std::string& format) {
        // ğŸ”‘ æ£€æŸ¥æ’­æ”¾é—¨æ§ï¼ˆå¦‚æœæœªå¯ç”¨ï¼Œä¸¢å¼ƒæ•°æ®ï¼‰
        if (!playback_enabled_.load()) {
            static int discard_count = 0;
            if (++discard_count % 50 == 1) {
                ESP_LOGD(TAG, "Audio discarded (playback disabled), count=%d", discard_count);
            }
            return;
        }

        // å¤„ç†æœ‰æ•ˆçš„éŸ³é¢‘æ•°æ®
        if (size > 0 && format == "opus") {
            static int packet_count = 0;
            packet_count++;

            ESP_LOGI(TAG, "âœ… Received TTS audio: size=%zu, format=%s, packet#%d",
                     size, format.c_str(), packet_count);

            // ğŸ”‘ æ¨é€åˆ°è§£ç é˜Ÿåˆ—æ’­æ”¾
            bool success = PushToAudioDecodeQueue(data, size);

            if (!success) {
                ESP_LOGW(TAG, "âš ï¸ Audio queue full, packet#%d dropped", packet_count);
            }
        }
    });

    ESP_LOGI(TAG, "Audio data callback configured");
}

// ============================================
// ç¬¬ 3 æ­¥ï¼šä¸»ç¨‹åºå®Œæ•´ç¤ºä¾‹
// ============================================

extern "C" void app_main() {
    // 1. åˆå§‹åŒ– WiFiï¼ˆçœç•¥ï¼‰
    ESP_LOGI(TAG, "WiFi connected");

    // 2. è·å– SDK å•ä¾‹å¹¶é…ç½®
    auto& sdk = streamind::SDK::GetInstance();

    streamind::Config config;
    config.device_id = "device-001";
    config.device_type = "robot";
    config.endpoint = "ws://your-server.com:8090/signals";  // â­ æ³¨æ„ /signals è·¯å¾„

    // 3. åˆå§‹åŒ– SDK
    streamind::Error err = sdk.Initialize(config);
    if (err != streamind::Error::OK) {
        ESP_LOGE(TAG, "SDK init failed: %s", sdk.GetLastError().c_str());
        return;
    }

    // 4. æ³¨å†ŒéŸ³é¢‘ TTS é€‚é…å™¨
    auto& registry = sdk.GetRegistry();
    streamind::RegisterHardwareAdapter<AudioTTSIntegration>(registry);

    // 5. è®¾ç½®éŸ³é¢‘æ•°æ®å›è°ƒï¼ˆæ¥æ”¶ TTS æµï¼‰
    SetupAudioDataCallback(sdk);

    // 6. è®¾ç½®æŒ‡ä»¤å›è°ƒï¼ˆè®°å½•æ‰§è¡Œç»“æœï¼‰
    sdk.SetDirectiveCallback([](const streamind::foundation::Directive& directive,
                                 bool success,
                                 const std::string& error_message) {
        if (success) {
            ESP_LOGI(TAG, "âœ… Directive executed: %s", directive.GetName().c_str());
        } else {
            ESP_LOGW(TAG, "âŒ Directive failed: %s - %s",
                     directive.GetName().c_str(), error_message.c_str());
        }
    });

    // 7. è®¾ç½®è¿æ¥å›è°ƒ
    sdk.SetConnectionCallback([&sdk](bool connected, const std::string& message) {
        if (connected) {
            ESP_LOGI(TAG, "âœ… Connected to platform");

            // â­ å¿…é¡»å¯åŠ¨æŒ‡ä»¤æ¥æ”¶
            streamind::Error recv_err = sdk.StartDirectiveReceiving();
            if (recv_err != streamind::Error::OK) {
                ESP_LOGE(TAG, "Failed to start directive receiving");
            }
        } else {
            ESP_LOGW(TAG, "Disconnected: %s", message.c_str());
            playback_enabled_ = false;  // æ–­çº¿æ—¶ç¦ç”¨æ’­æ”¾
        }
    });

    // 8. è¿æ¥åˆ°å¹³å°
    ESP_LOGI(TAG, "Connecting to platform...");
    sdk.Connect();

    ESP_LOGI(TAG, "Application started");
}
```

## å…³é”®è¦ç‚¹

### 1. åŒé€šé“æ¶æ„
- **æŒ‡ä»¤é€šé“**ï¼š`audio.opus_data_start`ï¼ˆå¼€å¯æ’­æ”¾ï¼‰
- **éŸ³é¢‘é€šé“**ï¼š`SetAudioDataCallback`ï¼ˆæ¥æ”¶ TTS æµï¼‰

### 2. æ’­æ”¾é—¨æ§æœºåˆ¶
- `playback_enabled_` æ§åˆ¶æ˜¯å¦æ¥å—éŸ³é¢‘æ•°æ®
- é¿å…åœ¨è†å¬æ—¶æ’­æ”¾ TTSï¼ˆé€ æˆå›éŸ³ï¼‰

### 3. å¼‚æ­¥ä»»åŠ¡ç®¡ç†
- ä½¿ç”¨ `ExecuteHardwareTask` ä¿è¯éŸ³é¢‘ä»»åŠ¡æ’é˜Ÿæ‰§è¡Œ
- `completion_callback` è‡ªåŠ¨ä¸ŠæŠ¥æ‰§è¡Œç»“æœ

### 4. å¿…é¡»è°ƒç”¨ StartDirectiveReceiving()
- åœ¨è¿æ¥æˆåŠŸå›è°ƒä¸­è°ƒç”¨
- å¦åˆ™æ— æ³•æ¥æ”¶æŒ‡ä»¤

### 5. WebSocket è·¯å¾„
- å¿…é¡»åŒ…å« `/signals` è·¯å¾„
- é”™è¯¯ï¼š`ws://server.com:8090/`
- æ­£ç¡®ï¼š`ws://server.com:8090/signals`

## é¢„æœŸæ—¥å¿—è¾“å‡º

```
I (123) AudioTTSExample: WiFi connected
I (130) StreamInd: SDK initialized
I (140) AudioTTSExample: AudioTTS registered: 1 action
I (145) AudioTTSExample: Audio data callback configured
I (160) AudioTTSExample: Connecting to platform...
I (500) AudioTTSExample: âœ… Connected to platform
I (505) StreamInd: Directive receiving started

# ç”¨æˆ·è¯´è¯åï¼Œå¹³å°è¿”å› TTS
I (15000) AudioTTSExample: âœ… Directive executed: audio.opus_data_start
I (15005) AudioTTSExample: Playback enabled
I (15010) AudioTTSExample: Result reported: playback_started=true
I (15020) AudioTTSExample: âœ… Received TTS audio: size=1024, format=opus, packet#1
I (15050) AudioTTSExample: âœ… Received TTS audio: size=1024, format=opus, packet#2
I (15080) AudioTTSExample: âœ… Received TTS audio: size=1024, format=opus, packet#3
...
```

## æœ€ä½³å®è·µ

1. **é—¨æ§æœºåˆ¶**ï¼šå§‹ç»ˆæ£€æŸ¥ `playback_enabled_` é¿å…æ— æ•ˆæ•°æ®
2. **å¼‚æ­¥å¤„ç†**ï¼šéŸ³é¢‘ä»»åŠ¡ä½¿ç”¨ `ExecuteHardwareTask` é¿å…é˜»å¡
3. **é”™è¯¯å¤„ç†**ï¼šé˜Ÿåˆ—æ»¡æ—¶ä¸¢å¼ƒæ•°æ®è€Œéé˜»å¡
4. **çŠ¶æ€ä¸ŠæŠ¥**ï¼šä½¿ç”¨ `completion_callback` è‡ªåŠ¨ä¸ŠæŠ¥ç»“æœ
5. **æ–­çº¿å¤„ç†**ï¼šè¿æ¥æ–­å¼€æ—¶ç¦ç”¨æ’­æ”¾
